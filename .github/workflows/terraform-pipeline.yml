name: Terraform Infrastructure Deployment

on:
  push:
    branches:
      - test
  workflow_dispatch:

jobs:
  setup-state-storage:
    name: Setup S3 and DynamoDB
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ vars.TF_VAR_aws_region }}

      - name: Check if S3 Bucket Exists
        run: |
          BUCKET_NAME="${{ vars.S3_BUCKET_NAME }}"
          REGION="${{ vars.TF_VAR_aws_region }}"
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Bucket $BUCKET_NAME already exists. Skipping creation."
          else
            if [ "$REGION" == "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET_NAME"
            else
              aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION" --create-bucket-configuration LocationConstraint="$REGION"
            fi
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          fi

      - name: Check if DynamoDB Table Exists
        run: |
          TABLE_NAME="my-terraform-lock-table"
          if aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null; then
            echo "DynamoDB table $TABLE_NAME already exists. Skipping creation."
          else
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --tags Key=Name,Value=TerraformLockTable Key=Environment,Value=${{ vars.TF_VAR_environment_name }}
          fi

  setup-ecr:
    name: Setup ECR Repositories
    runs-on: ubuntu-latest
    needs: setup-state-storage
    outputs:
      registry_url: ${{ steps.extract-ecr.outputs.registry_url }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Initialize Terraform for ECR with S3 Backend
        working-directory: terraform/modules/ecr
        run: |
          terraform init -backend-config="bucket=${{ vars.S3_BUCKET_NAME }}" \
                         -backend-config="key=terraform/ecr-state" \
                         -backend-config="region=${{ vars.TF_VAR_aws_region }}" \
                         -backend-config="encrypt=true" \
                         -backend-config="dynamodb_table=my-terraform-lock-table"

      - name: Apply Terraform for ECR
        working-directory: terraform/modules/ecr
        run: terraform apply -auto-approve

      - name: Extract ECR Registry URL
        id: extract-ecr
        working-directory: terraform/modules/ecr
        run: |
          echo "registry_url=$(terraform output -raw registry_url)" >> $GITHUB_OUTPUT

  terraform-deploy:
    name: Terraform Deployment
    runs-on: ubuntu-latest
    needs: setup-ecr
    outputs:
      vpc_id: ${{ steps.export-terraform.outputs.vpc_id }}
      private_subnet_ids: ${{ steps.export-terraform.outputs.private_subnet_ids }}
    steps:
      - name: Authenticate Docker with ECR
        run: |
          aws ecr get-login-password --region "${{ vars.TF_VAR_aws_region }}" | docker login --username AWS --password-stdin "${{ needs.setup-ecr.outputs.registry_url }}"

      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Initialize Terraform for Main Deployment with S3 Backend
        working-directory: terraform
        run: |
          terraform init -backend-config="bucket=${{ vars.S3_BUCKET_NAME }}" \
                         -backend-config="key=terraform/main-state" \
                         -backend-config="region=${{ vars.TF_VAR_aws_region }}" \
                         -backend-config="encrypt=true" \
                         -backend-config="dynamodb_table=my-terraform-lock-table"

      - name: Plan Terraform Changes
        working-directory: terraform
        run: terraform plan -var="registry_url=${{ needs.setup-ecr.outputs.registry_url }}"

      - name: Apply Terraform Changes
        working-directory: terraform
        run: terraform apply -auto-approve -var="registry_url=${{ needs.setup-ecr.outputs.registry_url }}"

      - name: Export Terraform Outputs
        id: export-terraform
        working-directory: terraform
        run: |
          echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT
          echo "private_subnet_ids=$(terraform output -json private_subnet_ids | jq -c)" >> $GITHUB_OUTPUT

  create-private-runner:
    name: Create Private Runner
    runs-on: ubuntu-latest
    needs: terraform-deploy
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      TF_VAR_aws_region: ${{ vars.TF_VAR_aws_region }}
      RUNNER_TOKEN: ${{ secrets.RUNNER_TOKEN }}
      INSTANCE_TYPE: "t3.micro"
    outputs:
      instance_id: ${{ steps.launch-ec2.outputs.instance_id }}
    steps:
      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
          aws configure set region $TF_VAR_aws_region

      - name: Select Subnet and Create Security Group
        id: sg-setup
        run: |
          SUBNET_ID=$(echo '${{ needs.terraform-deploy.outputs.private_subnet_ids }}' | jq -r '.[0]')
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT

          SECURITY_GROUP_ID=$(aws ec2 describe-security-groups \
            --filters Name=group-name,Values=github-runner-sg Name=vpc-id,Values=${{ needs.terraform-deploy.outputs.vpc_id }} \
            --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)

          if [ -z "$SECURITY_GROUP_ID" ]; then
            SECURITY_GROUP_ID=$(aws ec2 create-security-group \
              --group-name github-runner-sg \
              --description "Security group for GitHub Runner" \
              --vpc-id ${{ needs.terraform-deploy.outputs.vpc_id }} \
              --query 'GroupId' --output text)
          fi
          echo "security_group_id=$SECURITY_GROUP_ID" >> $GITHUB_OUTPUT

          aws ec2 authorize-security-group-ingress \
            --group-id $SECURITY_GROUP_ID \
            --protocol tcp \
            --port 443 \
            --source-group $SECURITY_GROUP_ID || true

          aws ec2 authorize-security-group-ingress \
            --group-id $SECURITY_GROUP_ID \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0 || true

      - name: Launch EC2 Instance with User Data
        id: launch-ec2
        run: |
          USER_DATA=$(cat <<EOF
          #!/bin/bash
          set -e
          sudo apt-get update -y
          sudo apt-get install -y docker.io git jq
          sudo systemctl start docker
          sudo systemctl enable docker
          mkdir actions-runner && cd actions-runner
          curl -o actions-runner-linux-x64-2.321.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.321.0/actions-runner-linux-x64-2.321.0.tar.gz
          tar xzf actions-runner-linux-x64-2.321.0.tar.gz
          ./config.sh --url https://github.com/vladimirdemari/Obligatorio-Soluciones-Cloud --token $RUNNER_TOKEN --labels private-runner
          ./svc.sh install
          ./svc.sh start
          EOF
          )
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0dba2cb6798deb6d8 \
            --count 1 \
            --instance-type $INSTANCE_TYPE \
            --subnet-id ${{ steps.sg-setup.outputs.subnet_id }} \
            --security-group-ids ${{ steps.sg-setup.outputs.security_group_id }} \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=GitHub-Runner}]' \
            --user-data "$USER_DATA" \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
